(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{280:function(t,a,s){"use strict";s.r(a);var e=s(4),r=Object(e.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"_10个容易忽略的前端兼容性问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_10个容易忽略的前端兼容性问题"}},[t._v("#")]),t._v(" 10个容易忽略的前端兼容性问题")]),t._v(" "),s("p",[s("img",{attrs:{src:"http://p3.pstatp.com/large/2c3b00027daba3e90ebc",alt:"An image"}})]),t._v(" "),s("p",[t._v("兼容问题一直是前端工程师们的梦魇。今天，老K为大家总结10个容易忽略的前端兼容性问题，供大家参考。")]),t._v(" "),s("h2",{attrs:{id:"在ios8系统中，用h5与app通信不能传带有复杂链接符的字符串。"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#在ios8系统中，用h5与app通信不能传带有复杂链接符的字符串。"}},[t._v("#")]),t._v(" 在ios8系统中，用h5与APP通信不能传带有复杂链接符的字符串。")]),t._v(" "),s("p",[t._v("在移动端开发中，经常需要h5与APP进行交互。这时就需要前端和APP开发人员双方规定一种传输协议。在协议中可以添加与APP交互需要的参数。但是在IOS8系统中，不支持参数中有复杂链接符，比如JSON格式的字符串、&等等。目前为止，下划线是唯一支持的连接符。")]),t._v(" "),s("h2",{attrs:{id:"safari中伪元素不支持css3动画。"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#safari中伪元素不支持css3动画。"}},[t._v("#")]),t._v(" safari中伪元素不支持CSS3动画。")]),t._v(" "),s("p",[t._v("在项目中肯定有很多前端开发人员使用css的伪元素属性进行页面构建。虽然这种方式很方便，但是在safari中并不支持伪元素的CSS3动画效果。")]),t._v(" "),s("h2",{attrs:{id:"safari中当一个元素的高度为零时，下边的同级元素的上外边距会覆盖这个元素。"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#safari中当一个元素的高度为零时，下边的同级元素的上外边距会覆盖这个元素。"}},[t._v("#")]),t._v(" safari中当一个元素的高度为零时，下边的同级元素的上外边距会覆盖这个元素。")]),t._v(" "),s("p",[t._v("在IE、chromet、FF中，即使一个元素的高度为0，也会把它当作块级元素看待，在页面中占据相应的位置。但是在safari中，高度为0的元素会被直接忽略。")]),t._v(" "),s("h2",{attrs:{id:"ios系统中在移动浏览器的页面中给按钮加js事件，其按钮必须是原生html按钮或者由-a-标签自定义构成。"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ios系统中在移动浏览器的页面中给按钮加js事件，其按钮必须是原生html按钮或者由-a-标签自定义构成。"}},[t._v("#")]),t._v(" ios系统中在移动浏览器的页面中给按钮加JS事件，其按钮必须是原生HTML按钮或者由"),s("code",[t._v("<a>")]),t._v("标签自定义构成。")]),t._v(" "),s("p",[t._v("这个问题当时困扰了小编很久，经过一番盘查，终于解决。原来在IOS系统中，浏览器只支持给原生HTML按钮或"),s("code",[t._v("<a>")]),t._v("标签加JS事件。")]),t._v(" "),s("h2",{attrs:{id:"在移动浏览器中给根元素（例如：html）添加overflow-hidden，只有在某些安卓自带浏览器（例如华为的自带浏览器）中才有效。"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#在移动浏览器中给根元素（例如：html）添加overflow-hidden，只有在某些安卓自带浏览器（例如华为的自带浏览器）中才有效。"}},[t._v("#")]),t._v(" 在移动浏览器中给根元素（例如："),s("code",[t._v("html")]),t._v("）添加"),s("code",[t._v("overflow:hidden")]),t._v("，只有在某些安卓自带浏览器（例如华为的自带浏览器）中才有效。")]),t._v(" "),s("p",[s("code",[t._v("overflow:hidden")]),t._v("这个CSS样式是大家常用到的。大家用这个样式可以实现很多目的。其中一个常用的就是隐藏内容溢出，把浏览器的滚动条隐藏。这个在PC端浏览中毫无问题。但是除了少数安卓自带浏览器，在大多数移动浏览器中，给根元素（例如："),s("code",[t._v("html")]),t._v("）添加这个样式就会失效。除非给根元素同时添加有实际数值的高度。为了适应移动端频幕的多种尺寸，只能运用JS动态获取视窗的高度，然后给根元素设置相同的高度，方可把移动浏览器的滚动条隐藏。")]),t._v(" "),s("h2",{attrs:{id:"在某些安卓系统手机自带浏览器（例如：华为手机）中，当父级元素是弹性盒子布局时（含有-webkit-box-flex属性），其子元素的margin-bottom失效，不能撑开父级元素。"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#在某些安卓系统手机自带浏览器（例如：华为手机）中，当父级元素是弹性盒子布局时（含有-webkit-box-flex属性），其子元素的margin-bottom失效，不能撑开父级元素。"}},[t._v("#")]),t._v(" 在某些安卓系统手机自带浏览器（例如：华为手机）中，当父级元素是弹性盒子布局时（含有"),s("code",[t._v("-webkit-box-flex")]),t._v("属性），其子元素的"),s("code",[t._v("margin-bottom")]),t._v("失效，不能撑开父级元素。")]),t._v(" "),s("p",[t._v("这个问题是小编在某个移动项目开发中碰到的。直接将外边距（margin）改为内边距(padding)就可解决。")]),t._v(" "),s("h2",{attrs:{id:"在safari中使用date-parse-解析时间字符串，其格式必须是yyyy-mm-dd-hh-mm-ss。"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#在safari中使用date-parse-解析时间字符串，其格式必须是yyyy-mm-dd-hh-mm-ss。"}},[t._v("#")]),t._v(" 在safari中使用"),s("code",[t._v("Date.parse()")]),t._v("解析时间字符串，其格式必须是YYYY/MM/DD HH:MM:SS。")]),t._v(" "),s("blockquote",[s("p",[s("code",[t._v("Date.parse()")]),t._v(" 方法解析一个表示某个日期的字符串，并返回从1970-1-1 00:00:00 UTC 到该日期对象（该日期对象的UTC时间）的毫秒数，如果该字符串无法识别，或者一些情况下，包含了不合法的日期数值（如：2015-02-31），则返回值为NaN。")])]),t._v(" "),s("p",[t._v("上述是JavaScript 参考文档的说明。严格来说，其解析的时间字符串必须是YYYY/MM/DD HH:MM:SS。但是，在IE、chrome、FF中，也可以解析YYYY-MM-DD HH:MM:SS或者YYYY.MM.DD HH:MM:SS这两种非标准格式的时间字符串。而safari只能解析标准格式。因此，开发人员在使用这个方法时，最好先把非标准格式转换成标准格式，这样就可以避免兼容问题。")]),t._v(" "),s("h2",{attrs:{id:"在ios系统中h5播放器不支持自动播放。"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#在ios系统中h5播放器不支持自动播放。"}},[t._v("#")]),t._v(" 在IOS系统中H5播放器不支持自动播放。")]),t._v(" "),s("p",[t._v("在iphone和ipad上用HTML5播放器时，不能自动播放，apple的解释说是为用户节省流量，我觉得这个考虑有点多余。")]),t._v(" "),s("p",[t._v("当时为了解决这个问题，做了些调研，最好的方法就是在IOS系统的浏览器中给页面根元素绑定一次touchstart事件播放流媒体文件，模拟自动播放。")]),t._v(" "),s("h2",{attrs:{id:"标准浏览器是只认识documentelement-scrolltop的，但chrome却不认识这个，在有文档声明时，chrome也只认识document-body-scrolltop。"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#标准浏览器是只认识documentelement-scrolltop的，但chrome却不认识这个，在有文档声明时，chrome也只认识document-body-scrolltop。"}},[t._v("#")]),t._v(" 标准浏览器是只认识documentElement.scrollTop的，但chrome却不认识这个，在有文档声明时，chrome也只认识document.body.scrollTop。")]),t._v(" "),s("p",[t._v("document.body.scrollTop与document.documentElement.scrollTop两者有个特点，就是同时只会有一个值生效。比如document.body.scrollTop能取到值的时候，document.documentElement.scrollTop就会始终为0；反之亦然。所以，如果要得到网页的真正的scrollTop值，可以这样：")]),t._v(" "),s("div",{staticClass:"language-javascript extra-class"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//第一种方法")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" scrollTop "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" document"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("body"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("scrollTop"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v("document"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("documentElement"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("scrollTop"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//第二种方法")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" scrollTop "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" document"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("body"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("scrollTop "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("?")]),t._v(" document"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("body"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("scrollTop "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" document"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("documentElement"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("scrollTop"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//第三种方法")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" scrollTop "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" document"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("body"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("scrollTop "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("||")]),t._v(" document"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("documentElement"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("scrollTop"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("p",[t._v("任选上述其中一种方式都可以解决。")]),t._v(" "),s("h2",{attrs:{id:"我们常说的事件处理时的event属性，在标准浏览器其是传入的，ie下由window-event获取的。并且获取目标元素的方法也不同，标准浏览器是event-target，而ie下是event-srcelement"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#我们常说的事件处理时的event属性，在标准浏览器其是传入的，ie下由window-event获取的。并且获取目标元素的方法也不同，标准浏览器是event-target，而ie下是event-srcelement"}},[t._v("#")]),t._v(" 我们常说的事件处理时的event属性，在标准浏览器其是传入的，IE下由window.event获取的。并且获取目标元素的方法也不同，标准浏览器是event.target，而IE下是event.srcElement")]),t._v(" "),s("p",[t._v("具体参考《javascript高级程序设计(第三版)》")])])}),[],!1,null,null,null);a.default=r.exports}}]);